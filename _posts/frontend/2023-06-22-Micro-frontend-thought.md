---
title: "Method of micro frontend implementation"
last_modified_at: 2023-06-22T06:46:02-05:00
categories:
  - Blog
tags:
  - Micro frontend
---

[Martin Flower 님의 블로그](https://martinfowler.com/articles/micro-frontends.html) 번역을 베이스로 했습니다  
<br/>

> 좋은 프론트엔드 개발은 어렵다. 많은 팀이 크고 복잡한 제품을 동시에 작업할 수 있도록 프론트엔드 개발을 확장하는 것은 훨씬 더 어렵다.
> 여기에서는 모놀리스를 더 작고 관리가 용이한 조각으로 나누는 최근 추세와, 아 아키텍처가 어떻게 효율적으로 프론트엔드 코드 작업을 할 수 있는지와 그 효과가 무엇인지를 설명한다.
> 다양한 혜택 그리고 이를 이루기 위한 비용에 대해 이야기 하고, 사용 가능한 구현 옵션 중 일부를 다루고 예제를 통해서 자세히 살펴본다.

최근 많은 기업들이 복잡하고 현대적인 웹 개발에 필요한 아키텍처와 조직구조에 점점 더 많은 관심을 기술이고 있다.  
모노리스식 프론트엔드를 (독립적으로 개발, 테스트 및 배포할 수 있는) 더 작고 단순한 덩어리로 분해하는 패턴이 등장하는 동시에 고객에게는 여천히 응집력 있는 단일 제품으로 보이도록 하는 
마이크로 프론트엔드 기술이 많은 관심을 받고 있으며, 다음과 같이 정의한다.  
<br/>
> "독립적으로 제공 가능한 프론트엔드 어플리케이션이 더 큰 전체로 구성되는 아키텍처 스타일"  
<br/>

미국에 소재한 글로벌 소프트웨어 컨설팅 회사인) Thoughtworks (소트웍스)에서는 2016년부터 마이크로 프론트엔드를 조직에서 갖추어야 할 중요한 기술로 나열했습니다.  
사실 백엔드 보다는 프론트엔드 개발에 더 많은 개발자의 노력과 땀이 소요되기 때문에, 프론트엔드에서의 Business Agility를 갖출 수 있느냐의 여부가 조직의 경쟁력에 많은 영향을 미친다고 볼 수 있다.  
이런 측면에서 보면 소트웍스에서의 마이크로 프론트엔드 기술 선정은 (어찌보면) 당연하다고 볼 수도 있겠다.  

마이크로 프론트엔드를 적용하면 많은 이점을 얻을 수 있다. 하지만 단점도 존재할 수 있는데 (예를 들면, 코드가 중복될 수 있고 이로 인해서 사용자가 다운로드해야 하는 바이트수가 증가하거나 개발팀 자율성의 급격한 증가로 인해 팀이 작업하는 방식이 파편화 될 수 있음)  
그럼에도 불구하고 이런 단점을 얼마든지 극복할 수 잇으며, 단점보다는 얻을 수 있는 이점이 훨씬 더 크다고 믿고 있다.  

## 마이크로 프론트엔드 채택으로 얻을 수 있는 이익 
특정 기술 접근방식이나 구현 세부사항 측면에서 마이크로 프론트엔드를 정의하는 대신, 나타나는 속성과 그 속성이 제공하는 이점 측면에서 살펴본다.  
<br/>
#### 증분 업그레이드  
증분 업그레이드는 (많은 조직에서) 마이크로 프론트엔드의 여정의 시작점이 된다.  
기존의 모노리스식 프론트엔드는 복잡하고 비대하며 시간이 지나면서 점점 스파게티 코드가 되어 간다.  
어느 시점에서는 차라리 전체 코드를 재작성하는 것이 더 낫다고 느끼는 시점이 온다.  
하지만 전체를 한꺼번에 다시 재작성 하는 것은 매우 위험한 일이며, 이 위험을 피하기 위해 오래된 프론트엔드를 하나씩 바꾸어 나가는 방식을 선호한다.  
<br/>
이럴 때에 종종 마이크로 프론트엔드 아키텍처로 이어지게 된다.  
프론트엔드 아키텍처를 체책함에 따라, 여러 팀이 참여하게 되며 각 팀은 프론트엔드의 맡은 부분에 대해 각각 결정을 내리고 아키텍처, 종속성 및 사용자 경험을 점진적으로 업그레이드할 수 있는 더 많은 자유가 주어지게 된다. 메인 프레임워크의 주요 변경사항이 있는 경우, (모든 마이크로 프론트엔드를 한번에 중단하고 모든 것을 업그레이드해야 하는 대신) 필요할 때마다 업그레이드 할 수 있다. 새로운 기술이나 새로운 상호 작용방식을 실헙하고 싶다면 원하는 방식으로 그렇게 할 수 있다.  
<br/>
#### 간단하고 분리된 코드 베이스
(당연한 말이지만) 각 개별 마이크로 프론트엔드의 소스코드는 단일 모놀리스 프론트엔드의 소스코드보다 훨씬 작다.  
이러한 작은 코드베이스는 개발자가 작업하기 더 간단하고 쉽다. 특히 서로에 대해 알면 안되는 구성 요소간의 의도하지 않은 부적절한 결합으로 인해 발생하는 복잡성을 피할 수 있다.  
마이크로 프론트엔드 아키텍처를 적용한다면, 마이크로 프론트엔드간 데이터 공유 등의 문제가 발생할 수가 있는데,  
때문에 (마이크로 프론트엔드 아키텍처를 적용한다면) 데이터와 이벤트의 흐름 등에 더 많은 노력을 기울여야 한다.   
<br/>
#### 독립배포
마이크로서비스 아키텍처와 마찬가지고, 독립배포는 마이크로 프론트엔드 아키텍처의 핵심이다.  
이렇게 하면 지정된 배포범위가 줄어들고 결과적으로 관련 위험이 줄어든다. 프론트엔드 코드가 호스팅되는 방식이나 위치에 상관없이 각 마이크로 프론트엔드에는 자체적으로  
지속적 빌드 파이프라인이 있어야 하며, 이 파이프라인은 프로덕션 단계까지 코드를 빌드, 테스트 및 배포하게 된다.  
다른 코드 베이스나 파이프라인의 현재 상태와 상관 없이 각 마이크로 프론트엔드를 (배포준비가 되면 언제든지) 배포할 수 있어야 한다.  

![image](https://github.com/lucky-sugar-park/lucky-sugar-park.github.io/assets/135287235/21f78f72-8d82-4ad2-912e-954496cf338a)  

#### 자율적인 팀  
코드베이스와 릴리스 주기를 모두 분리함으로써 얻을 수 있는 이점으로, (아이디어 구상에서 개발 및 배포에 이르기까지) 완전한 독립적인 팀을 꾸릴 수 있다.  
팀은 고객에게 가치를 제공하는데 필요한 모든 것을 완전히 소유할 수 있으므로, 빠르고 효과적으로 움직일 수 있다.  
이것이 제대로 작동하려면 팀은 **기술적 능력이 아닌 비즈니스 기능의 수직적 조각을 중심으로 구성** 되어야 한다.
이렇게 하는 쉬운 방법 중 하나는 최종 사용자가 볼 수 있는 것을 기반으로 프론트엔드를 분할사는 것이다.  
따라서 각 마이크로 프론트엔드는 어플리케이션의 단일 페이지를 캡슐화하고 단일 팀에서 종단간 소유된다.  

![image](https://github.com/lucky-sugar-park/lucky-sugar-park.github.io/assets/135287235/051e91a7-f3ea-4627-8ce6-ee452ceeed41)  

#### 간단히 말해서
요컨데, **마이크로 프론트엔드는 크고 무거운 것을 더 작고 관리하기 쉬운 조각으로 나눈 다음 이들 사이의 종석성에 대해서 명시하는 것이이다.**   
기술선택, 코드베이스, 팀 및 릴리스 프로세스는 모두 과도한 조정 없이 서로 독립적으로 작동하고 발전할 수 있어야 한다  

## 예제
고객이 배달음식을 주문할 수 있는 웹사이트를 상상해 보자. 표면적으로는 매우 간단한 개념이지만, 잘 세부적으로 들여다보면 놀라운 양의 세부사항이 있다.  
<br/>
- 고객이 레스토랑을 둘러보고 검색할 수 있는 랜딩 페이지가 있어야 한다. 식당은 가격, 요리 또는 고객이 이전에 주문한 것을 포함한 여러 속성으로 검색 및 필터링 할 수 있어야 한다.
- 각 레스토랑에는 메뉴 항목을 표시하고 고객이 할인, 식사거래 및 특별 요청과 함께 먹고 싶은 것을 선택할 수 있는 자체 페이지가 필요하다.
- 고객은 주문 내역을 보고, 배송을 추적하고 결제 옵션을 사용자 지정할 수 있는 프로필 페이지가 있어야 한다.

![image](https://github.com/lucky-sugar-park/lucky-sugar-park.github.io/assets/135287235/d44b4463-0fda-406a-9467-58e7fd1f4420)  

각 페이지에는 각기 전담 팀을 정당화할 수 있을 만큼 충분히 복잡하며 각 팀은 다은 모든 팀과 독립적으로 페이지에서 작업할 수 있어야 한다.  
다른 팀과의 충돌이나 조정에 대해 걱정하지 않고 코드를 개발, 테스트, 배포 및 유지할 수 있어야 한다. 그러나 고객은 여전히 하나의 완벽한 웹사이트를 보게 될 것이다. 

## 통합접근법 
위의 상당히 느슨한 정의를 감안할 때 마이크로 프론트엔드라고 합리적으로 불릴 수 있는 많은 접근이 있다. 여기에서는 몇 가지 예를 보여주고 장단점에 대해서 알아본다.  
모든 접근방식에 걸쳐 나타나는 아키텍처는 "일반적으로 어플리케이션의 각 페이지에 대한 마이크로 프론트엔드가 있고 다음과 같은 일을 하는 단일 어플리케이션이 있다" 이다.  
<br/>
- 머리글 및 바닥글과 같은 공통 페이지 요소를 렌더링 한다.  
- 인증 및 탐색과 같은 Cross cutting과 같은 문제가 해결되어야 한다.
- 다양한 마이크로 프론트엔드를 페이지와 함께 가져오고 각 마이크로 프론트엔드에게 언제, 어디서 렌더링할지를 알려준다.  

![image](https://github.com/lucky-sugar-park/lucky-sugar-park.github.io/assets/135287235/f0814192-2184-4a21-af92-394580ab448e)   
<일반적으로 페이지의 시각적 구조에서 아키텍처를 파생할 수 있다>  

#### Server side template composition  
각각 다른 앱에 맞는 HTML을 서비스 하는 서버를 backend에 두고, 요청한 URL에 따라 HTML을 writing 해주는 서버를 그 앞단에 놓아서 요청에 적합한  HTML을 응답으로 보내주는 구조이다.  
```
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>Feed me</title>
  </head>
  <body>
    <h1>🍽 Feed me</h1>
    <!--# include file="$PAGE.html" -->
  </body>
</html>
```
위 코드는 공통된 부분을 포함하고 있는 index.html 코드이다. 이 코드에는 서버 측의 Plug-in 페이지를 포함하고 있다.  
이제, Nginx 서버를 사용한다고 가정하자. $PAGE라는 변수를 요청 URL에 따라서 다르게 매칭시킬 수 있다.  
```
server {
    listen 8080;
    server_name localhost;

    root /usr/share/nginx/html;
    index index.html;
    ssi on;

    # Redirect / to /browse
    rewrite ^/$ http://localhost:8080/browse redirect;

    # Decide which HTML fragment to insert based on the URL
    location /browse {
      set $PAGE 'browse';
    }
    location /order {
      set $PAGE 'order';
    }
    location /profile {
      set $PAGE 'profile'
    }

    # All locations should render through index.html
    error_page 404 /index.html;
}
```

위 방법은 상당피 일반적인 서버측 구성이다. 우리가 위 예시를 마이크로 프론트엔드라고 정당하게 부를 수 있는 이유는 각 조각이 독립적인 팀에서 제공할 수 있는 독립적인 도메인 개념을 나타내는 방식으로 도메인을 분할했기 때문이다.  
위 코드는 단순한 것이지만, 각각 고유한 배포 파이프라인이 있다고 가정하여 다른 페이지에 영향을 미치지 않는 방향으로 어떤 페이지에 변경사항을 배포할 수 있다.  

더 큰 독립성을 위해 각 마이크로 프론트엔드를 렌더링/제공하는 별도의 서버를 둘 수도 있으며 이 서버는 다른 서버들의 앞 단에 위치할 수 있다.  
응답을 캐싱한다면 대기시간에 영향을 주지않고 서비스를 제공할 수 있을 것이다.  

![image](https://github.com/lucky-sugar-park/lucky-sugar-park.github.io/assets/135287235/d8fafe0a-09a3-4511-a387-5d838e8e93be)   

위 예제는 마이크로 프론트엔드가 반드시 새로운 기술일필요도 없고, 복잡할 필요도 없음을 잘 보여준다. 어떤 설계 결정이 코드베이스와 팀의 자율성에 어떤 영향을 미치는지 주의를 기술이는 한, 기술 스택에 관계 없이 많은 동일한 이점을 얻을 수 있다.  

최근의 웹 개발 기술과 매핑시켜보면, 특정 페이지 단위의 앱을 도메인별로 여러 개의 Nextjs 앱 서버에 배포해 놓고,
앞 단에 basePath로 요청이 들어왔을 때에, 뒷 단의 Nextjs로 필요한 페이지를 요청하고 앞 단의 서버에서 이를 통합하는 방식을 생각해 볼 수 있다.  

이 방법과 관련있는 솔루션으로 Nextjs의 multi-zones가 있다고 한다. Nextjs로 개발된 여러 개의 웹앱을 묶어서 배포하기 용이하게 만드는 방법이다.  
vercel은 multi-zones를 마이크로 프론트엔드 아키텍처를 구현하는 방법으로 제시 (https://vercel.com/templates/next.js/microfrontends)하고 있지만,
웹앱별 배포로 해결할 수 없는 문제는 해결하기 어려이 있다고 한다.  (https://maxkim-j.github.io/posts/runtime-integration-micro-frontends/) 참조.  

#### Build time integration  

#### Run time integration via iframe

#### Run time integration via web component

#### Run time integration via javascript
